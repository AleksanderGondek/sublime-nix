# [PackageDev] target_format: plist, ext: tmLanguage
# Made by Wout.Mertens@gmail.com
#
# This grammar tries to be complete, but regex-based highlighters
# can't be full parsers. Therefore it's a bit looser than the Nix
# parser itself and some legal constructs will be marked as illegal.
# It seems to work fine for nixpkgs.
#
# Cute hacks: Check out the attrset-for-sure and friends definitions
#
# While reading this, bear in mind that multi-line matches are not
# allowed and the end regex is tested before enclosed patterns regexes
# However, you can look-ahead to an end pattern with (?=...), which allows
# you to match everything in a block
---
name: Nix
scopeName: source.nix
fileTypes: [ "nix" ]
uuid: 0514fd5f-acb6-436d-b42c-7643e6d36c8f

patterns:
- include: '#expression'

repository:

  expression:
    patterns:
    - include: '#whitespace'
    - include: '#comment'
    - include: '#parens'
    - include: '#list'
    - include: '#string'
    - include: '#with-assert'
    - include: '#function-for-sure'
    - include: '#attrset-for-sure'
    - include: '#attrset-or-function'
    - include: '#let'
    - include: '#if'
    - include: '#interpolation'
    - name: keyword.operator.nix
      match: (\bor\b|\.|==|!=|!|\<\=|\<|\>\=|\>|&&|\|\||-\>|//|\?|\+\+|-|\*|/|\+)
    - name: constant.language.nix
      match: \b(builtins|true|false|null)\b
    - name: support.function.nix
      match: \b(scopedImport|import|isNull|abort|throw|baseNameOf|dirOf|removeAttrs|map|toString|derivationStrict|derivation)\b
    - name: constant.numeric.nix
      match: \b[0-9]+\b
    - include: '#bad-reserved'
    - include: '#parameter-name'
    - include: '#illegal'

  parens:
    begin: \(
    end: \)
    patterns:
    - include: '#expression'

  list:
    begin: \[
    end: \]
    patterns:
    - include: '#expression'

  attrset-for-sure:
    patterns:
    - match: \{\s*\}
      name: punctuation.definition.attrset.nix
    - begin: \b(rec|let)\s*(\{)
      beginCaptures:
        '1': {name: keyword.other.nix}
        '2': {name: punctuation.definition.attrset.nix}
      end: \}
      endCaptures: {'0': {name: punctuation.definition.attrset.nix}}
      patterns:
      - include: '#attrset-contents'
    - begin: \{(?=[^,?]*(=|;))
      beginCaptures: {'0': {name: punctuation.definition.attrset.nix}}
      end: \}
      endCaptures: {'0': {name: punctuation.definition.attrset.nix}}
      patterns:
      - include: '#attrset-contents'

  attrset-contents:
    patterns:
    - include: '#whitespace'
    - include: '#comment'
    - include: '#attribute-inherit'
    - include: '#bad-reserved'
    - include: '#attribute-bind'
    - include: '#illegal'

  function-for-sure:
    patterns:
    # x: ...
    - match: (\b[a-zA-Z\_][a-zA-Z0-9\_\'\-]*)\s*(:)
      captures:
        '1': {name: variable.parameter.nix}
        '2': {name: punctuation.definition.entity.function.1.nix}
    # {stuff}: ...
    - begin: (\{)(?=[^}]*\}\s*:)
      end: (\})\s*(@\s*([a-zA-Z\_][a-zA-Z0-9\_\'\-]*)\s*)?(:)
      beginCaptures:
        '0': {name: punctuation.definition.entity.function.2.nix}
      endCaptures:
        '1': {name: punctuation.definition.entity.function.nix}
        '2': {name: punctuation.definition.entity.function.nix}
        '3': {name: variable.parameter.nix}
        '5': {name: punctuation.definition.entity.function.nix}
      patterns:
      - include: '#function-contents'
    # {a, b ? c, ...
    - begin: (\{)(?=[^#}"'/=]*[,\?])
      beginCaptures:
        '0': {name: punctuation.definition.entity.function.3.nix}
      end: (\}\s*(@\s*([a-zA-Z\_][a-zA-Z0-9\_\'\-]*)\s*)?:)
      endCaptures:
        '1': {name: punctuation.definition.entity.function.nix}
        '3': {name: variable.parameter.nix}
        '5': {name: punctuation.definition.entity.function.nix}
      patterns:
      - include: '#function-contents'
    # arg @ {...
    - begin: ((\b[a-zA-Z\_][a-zA-Z0-9\_\'\-]*)\s*@\s*)(\{)
      beginCaptures:
        '3': {name: punctuation.definition.entity.function.4.nix}
      end: (\}\s*(@\s*([a-zA-Z\_][a-zA-Z0-9\_\'\-]*)\s*)?:)
      endCaptures:
        '0': {name: punctuation.definition.entity.function.nix}
      patterns:
      - include: '#function-contents'

  function-contents:
    patterns:
    - include: '#whitespace'
    - include: '#comment'
    - include: '#bad-reserved'
    - include: '#function-parameter'
    - include: '#illegal'

  attrset-or-function:
    begin: (\{)
    beginCaptures:
      '0': {name: punctuation.definition.attrset-or-function.nix}
    end: \}(\s*(@\s*([a-zA-Z\_][a-zA-Z0-9\_\'\-]*)\s*)?:)?
    endCaptures:
      '0': {name: punctuation.definition.attrset-or-function.nix}
    patterns:
    - include: '#whitespace'
    - include: '#comment'
    # We have no clue what to expect so we allow both until we hit one
    - begin: (?=\b(inherit\b|[a-zA-Z\_][a-zA-Z0-9\_\'\-]*(\s*=[^=]|\s+[a-zA-Z\_])))
      end: (?=\})
      patterns:
      - include: '#attrset-contents'
    - begin: (?=(,|\b[a-zA-Z\_][a-zA-Z0-9\_\'\-]*\s*[,?]))
      end: (?=\})
      patterns:
      - include: '#function-contents'
    - include: '#bad-reserved'
    - include: '#optional-default'
    - include: '#attribute-bind'
    - include: '#function-parameter'
    - include: '#illegal'    

  with-assert:
    begin: \b(with|assert)\b
    beginCaptures:
      '0': {name: keyword.other.nix}
    end: \;
    patterns:
    - include: '#expression'

  let:
    begin: \blet\b
    beginCaptures:
      '0': {name: keyword.other.nix}
    end: \bin\b
    endCaptures:
      '0': {name: keyword.other.nix}
    patterns:
    - include: '#whitespace'
    - include: '#comment'
    - include: '#attribute-inherit'
    - include: '#bad-reserved'
    - include: '#attribute-bind'
    - include: '#illegal'

  if:
    begin: \bif\b
    beginCaptures:
      '0': {name: keyword.other.nix}
    end: \belse\b
    endCaptures:
      '0': {name: keyword.other.nix}
    patterns:
    # This can only match once
    - begin: \bthen\b
      beginCaptures:
        '0': {name: keyword.other.nix}
      end: (?=\belse\b)
      patterns:
      - include: '#expression'
    - include: '#expression'

  comment-remark:
    match: (TODO|FIXME|BUG|\!\!\!):?
    captures:
      '1': {name: markup.bold.comment.nix }
  comment:
    patterns:
    - name: comment.block.nix
      begin: /\*([^*]|\*[^\/])*
      end: \*\/
      patterns:
      - include: '#comment-remark'
    - name: comment.line.number-sign.nix
      begin: \#
      end: $
      patterns:
      - include: '#comment-remark'

  interpolation:
    contentName: string.interpolated.nix
    begin: \$\{
    beginCaptures:
      "0":
        name: constant.character.begin.nix
    end: \}
    endCaptures:
      "0":
        name: constant.character.end.nix
    patterns:
    - include: 'source.nix'

  string-quoted:
    name: string.quoted.double.nix
    begin: \"
    end: \"
    patterns:
    - match: \\.
      name: constant.character.escape.nix
    - include: '#interpolation'

  string:
    patterns:
    - name: string.quoted.other.nix
      begin: \'\'
      end: \'\'(?!\$|\'|\\.)
      patterns:
      - name: constant.character.escape.nix
        match: \'\'(\$|\'|\\.)
      - include: '#interpolation'
    - include: '#string-quoted'
    - name: string.unquoted.path.nix
      match: ([a-zA-Z0-9\.\_\-\+]*(\/[a-zA-Z0-9\.\_\-\+]+)+)
    - name: string.unquoted.spath.nix
      match: (\<[a-zA-Z0-9\.\_\-\+]+(\/[a-zA-Z0-9\.\_\-\+]+)*\>)
    - name: string.unquoted.url.nix
      match: ([a-zA-Z][a-zA-Z0-9\+\-\.]*\:[a-zA-Z0-9\%\/\?\:\@\&\=\+\$\,\-\_\.\!\~\*\']+)

  parameter-name:
    match: \b[a-zA-Z\_][a-zA-Z0-9\_\'\-]*
    name: variable.parameter.nix

  attribute-name-single:
    match: \b[a-zA-Z\_][a-zA-Z0-9\_\'\-]*
    name: entity.other.attribute-name.single.nix

  attribute-name:
    # Unfortunately, no pattern ordering can be enforced. Ah well.
    patterns:
    - match: \b[a-zA-Z\_][a-zA-Z0-9\_\'\-]*
      name: entity.other.attribute-name.multipart.nix
    - match: \.
    - include: '#string-quoted'
    - include: '#interpolation'

  # Need this split out for ordering
  optional-default:
    begin: \b([a-zA-Z\_][a-zA-Z0-9\_\'\-.]*)\s*(\?)
    beginCaptures:
      '1': {name: variable.parameter.nix}
      '2': {name: keyword.operator.nix}
    end: (,|(?=\}))
    endCaptures:
      '0': {name: punctuation.section.function.arguments.nix}
    patterns:
    - include: '#expression'
  function-parameter:
    patterns:
    - match: (\.\.\.)
      name: keyword.operator.nix
    - include: '#optional-default'
    - begin: \b([a-zA-Z\_][a-zA-Z0-9\_\'\-.]*)
      end: (,|(?=\}))
      beginCaptures:
        '1': {name: variable.parameter.nix}
        '2': {name: keyword.operator.nix}
      patterns:
      - include: '#whitespace'
      - include: '#comment'

  attribute-inherit:
    begin: \binherit\b
    beginCaptures:
      '0': {name: keyword.other.inherit.nix}
    end: \;
    endCaptures:
      '0': {name: punctuation.terminator.inherit.nix}
    patterns:
    # This should only match once, in front. Ah well.
    - begin: \(
      end: \)
      beginCaptures:
        '0': {name: punctuation.section.function.arguments.nix}
      endCaptures:
        '0': {name: punctuation.section.function.arguments.nix}
      patterns:
      - include: '#expression'
    - include: '#bad-reserved'
    - include: '#attribute-name-single'
    - include: '#whitespace'
    - include: '#comment'
    - include: '#illegal'

  attribute-bind:
    patterns:
    - include: '#attribute-name'
    # Wish this could match only after an attribute. Ah well.
    - begin: \=
      beginCaptures:
        '0': {name: keyword.operator.bind.nix}
      end: \;
      endCaptures:
        '0': {name: punctuation.terminator.bind.nix}
      patterns:
      - include: '#expression'

  whitespace:
    match: \s+

  illegal:
    match: .
    name: invalid.illegal

  bad-reserved:
    match: \b(if|then|else|assert|with|let|in|rec|inherit|or)\b
    name: invalid.illegal.reserved.nix
